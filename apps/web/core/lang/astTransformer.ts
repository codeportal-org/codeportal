import { full as acornWalkFull } from "acorn-walk"
import {
  ArrowFunctionExpression,
  AssignmentExpression,
  BinaryExpression,
  BlockStatement,
  Expression,
  ExpressionStatement,
  FunctionDeclaration,
  Identifier,
  IfStatement,
  JSXElement,
  JSXExpressionContainer,
  JSXFragment,
  JSXIdentifier,
  JSXText,
  Literal,
  MemberExpression,
  ObjectExpression,
  Program,
  SimpleCallExpression,
  Statement,
  TryStatement,
  UnaryExpression,
  VariableDeclaration,
} from "estree-jsx"

import { nanoid } from "@/lib/nanoid"

import {
  AssignmentOperator,
  AssignmentStatement,
  ComponentNode,
  ElseIfNode,
  ExpressionNode,
  FunctionCallNode,
  FunctionNode,
  IfStatementNode,
  LiteralNode,
  NAryExpression,
  NAryOperator,
  NAryOperatorSymbols,
  ObjectNode,
  ParamDeclaration,
  PathAccessNode,
  ProgramNode,
  ReferenceNode,
  ReturnStatementNode,
  StateChangeStatement,
  StateStatement,
  StatementNode,
  StringLiteral,
  TryStatementNode,
  UIElementNode,
  UIExpressionNode,
  UIFragmentNode,
  UINode,
  UIPropNode,
  UISpreadPropNode,
  UITextNode,
  UnaryExpressionNode,
  VarStatement,
} from "./codeTree"

/**
 * Transforms the JS generated by GPT, that is transformed to AST (ESTree) format, into into Portal Code Tree format.
 * Portal Code Tree format is simpler and specific to PortalLang.
 */
export class ASTtoCTTransformer {
  componentMode = false

  /**
   * If true it make the top function a component.
   * This is to account for incomplete components during AI generation.
   * Very Editor specific use case.
   * */
  topLevelComponent = false

  /** Next id to be used by a node */
  idCounter = 0

  useLocalIds = false

  private getNewId() {
    if (this.useLocalIds) {
      const id = this.idCounter.toString()
      this.idCounter++
      return id
    } else {
      return nanoid("stronger")
    }
  }

  /**
   * Stack of scopes. Each scope maps names to ids.
   */
  scopeStack: Map<string, string>[] = []

  globalScope: Map<string, string> = new Map()

  addGlobal(name: string, id: string) {
    this.globalScope.set(name, id)
  }

  private addToScope(name: string, id: string) {
    if (this.scopeStack.length === 0) {
      throw new Error("No scope to add to")
    }

    this.scopeStack[this.scopeStack.length - 1]!.set(name, id)
  }

  private pushScope() {
    this.scopeStack.push(new Map())
  }

  private popScope() {
    this.scopeStack.pop()
  }

  private resolveIdentifier(name: string): string {
    if (this.scopeStack.length === 0) {
      throw new Error("No scope to resolve identifier")
    }

    for (let i = this.scopeStack.length - 1; i >= 0; i--) {
      const id = this.scopeStack[i]!.get(name)

      if (id) {
        return id
      }
    }

    const id = this.globalScope.get(name)

    if (id) {
      return id
    }

    throw new Error(`Identifier ${name} not found`)
  }

  constructor({
    topLevelComponent = false,
    debugMode = false,
  }: { topLevelComponent?: boolean; debugMode?: boolean } = {}) {
    this.topLevelComponent = topLevelComponent

    if (debugMode) {
      this.useLocalIds = true
    }
  }

  reset() {
    this.idCounter = 0
    this.scopeStack = []
    this.globalScope = new Map()
    this.componentMode = false
  }

  transform(node: Program) {
    if (node.type === "Program") {
      return this.transformProgram(node)
    }
  }

  transformProgram(node: Program): ProgramNode {
    const programNode: ProgramNode = {
      type: "program",
      id: this.getNewId(),
      body: [],
      idCounter: this.idCounter,
    }

    programNode.body.push(...this.transformStatementList(node.body as Statement[], true))

    programNode.idCounter = this.idCounter

    return programNode
  }

  transformComponent(node: FunctionDeclaration): ComponentNode {
    if (node.id === null) {
      throw new Error("Function declaration must have a name (component declaration)")
    }

    this.componentMode = true

    let componentNode: ComponentNode = {
      type: "component",
      id: this.getNewId(),
      name: node.id.name,
      body: [],
    }

    this.addToScope(componentNode.name, componentNode.id)

    this.pushScope()

    for (const statement of node.body.body) {
      componentNode.body.push(this.transformStatement(statement))
    }

    this.popScope()

    return componentNode
  }

  transformFunctionDeclaration(node: FunctionDeclaration): FunctionNode {
    if (node.id === null) {
      throw new Error("Function declaration must have a name")
    }

    const functionNode: FunctionNode = {
      type: "function",
      id: this.getNewId(),
      name: node.id.name,
      params: [],
      body: [],
    }

    this.addToScope(functionNode.name!, functionNode.id)

    this.pushScope()

    functionNode.params?.push(
      ...node.params.map((param) => {
        if (param.type !== "Identifier") {
          throw new Error(`Unknown function param type: ${param.type}`)
        }

        const paramNode = {
          type: "param",
          id: this.getNewId(),
          name: param.name,
        } satisfies ParamDeclaration

        this.addToScope(paramNode.name, paramNode.id)

        return paramNode
      }),
    )

    for (const statement of node.body.body) {
      functionNode.body.push(this.transformStatement(statement))
    }

    this.popScope()

    return functionNode
  }

  transformStatementList(statementList: Statement[], isRoot = false): StatementNode[] {
    const statementNodes: StatementNode[] = []

    this.pushScope()

    for (const statement of statementList) {
      if (statement.type === "FunctionDeclaration") {
        // see if it is a React component
        const statements = statement.body.body
        let lastStatement: any = statements[statements.length - 1]

        if (
          (this.topLevelComponent && isRoot) ||
          (lastStatement &&
            lastStatement.type === "ReturnStatement" &&
            lastStatement.argument?.type === "JSXElement")
        ) {
          statementNodes.push(this.transformComponent(statement))
        } else {
          statementNodes.push(this.transformFunctionDeclaration(statement))
        }
      } else {
        statementNodes.push(this.transformStatement(statement as Statement))
      }
    }

    this.popScope()

    return statementNodes
  }

  transformStatement(node: Statement): StatementNode | any {
    if (node.type === "VariableDeclaration") {
      return this.transformVariableDeclaration(node)
    } else if (node.type === "ReturnStatement") {
      return this.transformReturnStatement(node)
    } else if (node.type === "ExpressionStatement") {
      return this.transformExpressionStatement(node)
    } else if (node.type === "TryStatement") {
      return this.transformTryStatement(node)
    } else if (node.type === "IfStatement") {
      return this.transformIfStatement(node)
    } else if (node.type === "FunctionDeclaration") {
      return this.transformFunctionDeclaration(node)
    } else {
      throw new Error(`Unknown statement type: ${node.type}`)
    }
  }

  transformVariableDeclaration(
    node: VariableDeclaration,
  ): VarStatement | FunctionNode | StateStatement {
    if (node.declarations.length > 1) {
      throw new Error("Multiple variable declarators in a declaration is not supported")
    }

    if (!node.declarations[0]) {
      throw new Error("No variable declarator in declaration")
    }

    // pattern matching React state, it detects `React.useState`
    if (this.componentMode) {
      if (
        node.declarations[0].init?.type === "CallExpression" &&
        node.declarations[0].init.callee.type === "MemberExpression" &&
        node.declarations[0].init.callee.object.type === "Identifier" &&
        (node.declarations[0].init.callee.object as Identifier)?.name === "React" &&
        node.declarations[0].init.callee.property?.type === "Identifier" &&
        (node.declarations[0].init.callee.property as Identifier)?.name === "useState" &&
        node.declarations[0].id.type === "ArrayPattern" &&
        node.declarations[0].id?.elements[0]?.type === "Identifier" &&
        node.declarations[0].id?.elements[1]?.type === "Identifier"
      ) {
        const stateNode: StateStatement = {
          type: "state",
          id: this.getNewId(),
          name: node.declarations[0].id?.elements[0]?.name,
          value: this.transformExpression(node.declarations[0].init.arguments[0] as Expression),
        }

        this.addToScope(stateNode.name, stateNode.id)

        const setStateName = node.declarations[0].id?.elements[1].name
        this.addToScope(setStateName, `#state-${stateNode.name}`)

        return stateNode
      }
    }

    // transform arrow functions into regular functions
    if (
      node.declarations[0].init?.type === "ArrowFunctionExpression" &&
      node.declarations[0].id.type === "Identifier"
    ) {
      const functionNode: FunctionNode = {
        type: "function",
        id: this.getNewId(),
        name: node.declarations[0].id.name,
        params: [],
        body: [],
      }

      this.addToScope(functionNode.name!, functionNode.id)

      this.pushScope()

      functionNode.params?.push(
        ...node.declarations[0].init.params.map((param) => {
          if (param.type !== "Identifier") {
            throw new Error(`Unknown arrow function param type: ${param.type}`)
          }

          const paramNode = {
            type: "param",
            id: this.getNewId(),
            name: param.name,
          } satisfies ParamDeclaration

          this.addToScope(paramNode.name, paramNode.id)

          return paramNode
        }),
      )

      if (node.declarations[0].init.expression) {
        functionNode.body.push({
          type: "return",
          id: this.getNewId(),
          arg: this.transformExpression(node.declarations[0].init.body as Expression),
        })
      } else {
        for (const statement of (node.declarations[0].init.body as BlockStatement).body) {
          functionNode.body.push(this.transformStatement(statement))
        }
      }

      this.popScope()

      return functionNode
    }

    // Regular variable declaration

    if (node.declarations[0].id.type !== "Identifier") {
      throw new Error(`Unknown variable declarator type: ${node.declarations[0].id.type}`)
    }

    const varStatement: VarStatement = {
      type: "var",
      id: this.getNewId(),
      name: (node.declarations[0].id as Identifier).name,
      value: this.transformExpression(node.declarations[0].init as Expression),
    }

    this.addToScope(varStatement.name, varStatement.id)

    return varStatement
  }

  transformReturnStatement(node: any): any {
    return {
      type: "return",
      id: this.getNewId(),
      arg: this.transformExpression(node.argument),
    }
  }

  transformExpression(node: Expression): ExpressionNode {
    if (node.type === "Identifier") {
      return this.transformIdentifier(node)
    } else if (node.type === "Literal") {
      return this.transformLiteral(node)
    } else if (node.type === "BinaryExpression") {
      return this.transformBinaryExpression(node)
    } else if (node.type === "UnaryExpression") {
      return this.transformUnaryExpression(node)
    } else if (node.type === "JSXElement") {
      return this.transformJSXElement(node)
    } else if (node.type === "CallExpression") {
      return this.transformCallExpression(node)
    } else if (node.type === "MemberExpression") {
      return this.transformMemberExpression(node)
    } else if (node.type === "ObjectExpression") {
      return this.transformObjectExpression(node)
    } else if (node.type === "ArrowFunctionExpression") {
      return this.transformArrowFunctionExpression(node)
    } else if (node.type === "AwaitExpression") {
      // We strip await expressions
      return this.transformExpression(node.argument)
    }

    throw new Error(`Unknown expression type: ${node.type}`)
  }

  transformIdentifier(node: any): ReferenceNode {
    const resolvedId = this.resolveIdentifier(node.name)

    return {
      type: "ref",
      id: this.getNewId(),
      refId: resolvedId,
    }
  }

  transformLiteral(node: Literal): LiteralNode {
    const valueType = typeof node.value

    if (valueType === "string") {
      return {
        type: "string",
        id: this.getNewId(),
        value: node.value as string,
      } satisfies StringLiteral
    } else if (valueType === "number") {
      return {
        type: "number",
        id: this.getNewId(),
        value: node.value as number,
      }
    } else if (valueType === "boolean") {
      return {
        type: "boolean",
        id: this.getNewId(),
        value: node.value as boolean,
      }
    }

    throw new Error(`Unknown literal type: ${typeof node.value}`)
  }

  transformBinaryExpression(node: BinaryExpression): NAryExpression {
    const nAryId = this.getNewId()
    const args: ExpressionNode[] = []
    const operators: NAryOperator[] = []

    let operator = node.operator === "===" ? "==" : (node.operator as NAryOperator)

    if (NAryOperatorSymbols.indexOf(operator as any) === -1) {
      throw new Error(`Unknown binary operator: ${node.operator}`)
    }

    let current: any = node
    while (current.type === "BinaryExpression" && node.operator === current.operator) {
      args.push(this.transformExpression(current.right))
      operators.push(operator)

      current = current.left
    }

    args.push(this.transformExpression(current))

    return {
      type: "nary",
      id: nAryId,
      operators,
      args: args.reverse(),
    }
  }

  transformJSXElement(node: JSXElement): UIElementNode {
    const uiElementNode: UIElementNode = {
      type: "ui element",
      id: this.getNewId(),
      name: (node.openingElement.name as JSXIdentifier).name,
      props: node.openingElement.attributes
        .map((attribute) => {
          return attribute.type === "JSXAttribute" &&
            attribute.name.type === "JSXIdentifier" &&
            attribute.value
            ? ({
                type: "ui prop",
                id: this.getNewId(),
                name: attribute.name.name as string,
                value:
                  attribute.value.type === "Literal"
                    ? this.transformLiteral(attribute.value)
                    : attribute.value.type === "JSXExpressionContainer"
                    ? this.transformExpression(attribute.value.expression as Expression)
                    : this.transformJSXElement(attribute.value as JSXElement),
              } satisfies UIPropNode)
            : attribute.type === "JSXSpreadAttribute" && attribute.argument
            ? ({
                type: "ui spread prop",
                id: this.getNewId(),
                arg: this.transformExpression(attribute.argument),
              } satisfies UISpreadPropNode)
            : null
        })
        .filter((attribute) => attribute !== null) as (UIPropNode | UISpreadPropNode)[],
      children: node.children
        .map((child) => {
          if (child.type === "JSXElement") {
            return this.transformJSXElement(child)
          } else if (child.type === "JSXText") {
            return this.transformJSXText(child)
          } else if (child.type === "JSXExpressionContainer") {
            return this.transformUIExpression(child)
          } else if (child.type === "JSXFragment") {
            return this.transformJSXFragment(child)
          } else {
            throw new Error(`Unknown JSX child type: ${child.type}`)
          }
        })
        .filter((child: any) => child !== null) as UINode[],
    }

    if (uiElementNode.children?.length === 0) {
      delete uiElementNode.children
    }

    return uiElementNode
  }

  transformJSXText(node: JSXText): UITextNode | null {
    // ignore whitespace like JSX with value "\n   " that is just indentation
    if (node.value.trim() === "") {
      return null
    }

    return {
      type: "ui text",
      id: this.getNewId(),
      text: collapseWhitespace(node.value),
    } satisfies UITextNode
  }

  transformJSXFragment(node: JSXFragment): UIFragmentNode {
    return {
      type: "ui fragment",
      id: this.getNewId(),
      children: node.children
        .map((child: any) => {
          if (child.type === "JSXElement") {
            return this.transformJSXElement(child)
          } else if (child.type === "JSXText") {
            return this.transformJSXText(child)
          } else if (child.type === "JSXExpressionContainer") {
            return this.transformUIExpression(child.expression)
          } else if (child.type === "JSXFragment") {
            return this.transformJSXFragment(child)
          } else {
            throw new Error(`Unknown JSX child type: ${child.type}`)
          }
        })
        .filter((child) => child !== null) as UINode[],
    }
  }

  transformUIExpression(node: JSXExpressionContainer): UIExpressionNode {
    return {
      type: "ui expression",
      id: this.getNewId(),
      expression: this.transformExpression(node.expression as Expression),
    }
  }

  transformCallExpression(node: SimpleCallExpression): FunctionCallNode {
    const functionCallId = this.getNewId()

    let callee: ReferenceNode | PathAccessNode

    if (node.callee.type === "MemberExpression") {
      callee = this.transformMemberExpression(node.callee)
    } else if (node.callee.type === "Identifier") {
      callee = this.transformIdentifier(node.callee)
    } else {
      throw new Error(`Unknown call expression callee type: ${node.callee.type}`)
    }

    return {
      type: "function call",
      id: functionCallId,
      callee,
      args: node.arguments.map((argument: any) => this.transformExpression(argument)),
    }
  }

  transformExpressionStatement(node: ExpressionStatement): StatementNode {
    if (node.expression.type === "AssignmentExpression") {
      return this.transformAssignmentExpression(node.expression)
    } else if (node.expression.type === "CallExpression") {
      return this.transformCallExpression(node.expression)
    }

    throw new Error(`Unknown expression statement type: ${node.expression.type}`)
  }

  transformAssignmentExpression(node: AssignmentExpression): AssignmentStatement {
    const assignmentNodeId = this.getNewId()

    const left = node.left

    let leftNode: ReferenceNode | PathAccessNode
    if (left.type === "MemberExpression") {
      leftNode = this.transformMemberExpression(left)
    } else if (left.type === "Identifier") {
      leftNode = this.transformIdentifier(left)
    } else {
      throw new Error(`Unknown assignment left type: ${left.type}`)
    }

    return {
      type: "assignment",
      id: assignmentNodeId,
      operator: node.operator,
      left: leftNode,
      right: this.transformExpression(node.right),
    }
  }

  transformMemberExpression(node: MemberExpression): PathAccessNode {
    const pathAccessId = this.getNewId()
    let path: any[] = []

    let current = node
    while (current.type === "MemberExpression") {
      if (current.computed) {
        path.push(this.transformExpression(current.property as Expression))
      } else {
        path.push({
          type: "string",
          id: this.getNewId(),
          value: (current.property as Identifier).name,
        } satisfies StringLiteral)
      }
      current = current.object as MemberExpression
    }

    path.push(this.transformExpression(current))

    return {
      type: "path access",
      id: pathAccessId,
      path: path.reverse(),
    }
  }

  transformUnaryExpression(node: UnaryExpression): UnaryExpressionNode | ExpressionNode {
    if (
      node.operator === "typeof" ||
      node.operator === "void" ||
      node.operator === "delete" ||
      node.operator === "~"
    ) {
      throw new Error(`Unsupported unary operator: ${node.operator}`)
    }

    if (node.operator === "+") {
      // unwrap the unnecessary unary expression
      return this.transformExpression(node.argument)
    }

    const unaryExpressionId = this.getNewId()

    return {
      type: "unary",
      id: unaryExpressionId,
      operator: node.operator,
      arg: this.transformExpression(node.argument),
    }
  }

  transformObjectExpression(node: ObjectExpression): ObjectNode {
    const object: ObjectNode = {
      type: "object",
      id: this.getNewId(),
      props: [],
    }

    for (const property of node.properties) {
      if (property.type !== "Property") {
        throw new Error(`Unknown object property type: ${property.type}`)
      }

      const propertyId = this.getNewId()

      const name = property.computed
        ? this.transformExpression(property.key as Expression)
        : ({
            type: "string",
            id: this.getNewId(),
            value: (property.key as Identifier).name,
          } satisfies StringLiteral)

      object.props.push({
        type: "property",
        id: propertyId,
        name,
        value: this.transformExpression(property.value as Expression),
      })
    }

    return object
  }

  transformTryStatement(node: TryStatement): TryStatementNode {
    const tryStatement: TryStatementNode = {
      type: "try",
      id: this.getNewId(),
      body: [],
      catch: [],
    }

    tryStatement.body.push(...this.transformStatementList(node.block.body))

    if (node.handler) {
      this.pushScope()
      if (node.handler.param) {
        if (node.handler.param.type !== "Identifier") {
          throw new Error(`Unknown catch param type: ${node.handler.param.type}`)
        }
        const paramNode = {
          type: "param",
          id: this.getNewId(),
          name: node.handler.param.name,
        } satisfies ParamDeclaration

        this.addToScope(paramNode.name, paramNode.id)

        tryStatement.catchParam = paramNode
      }

      for (const statement of node.handler.body.body) {
        tryStatement.catch.push(this.transformStatement(statement))
      }
      this.popScope()
    }

    if (node.finalizer) {
      tryStatement.finally = this.transformStatementList(node.finalizer.body)
    }

    return tryStatement
  }

  transformArrowFunctionExpression(node: ArrowFunctionExpression): FunctionNode {
    const functionNode: FunctionNode = {
      type: "function",
      id: this.getNewId(),
      params: [],
      body: [],
    }

    this.pushScope()

    functionNode.params?.push(
      ...node.params.map((param) => {
        if (param.type !== "Identifier") {
          throw new Error(`Unknown arrow function param type: ${param.type}`)
        }

        const paramNode = {
          type: "param",
          id: this.getNewId(),
          name: param.name,
        } satisfies ParamDeclaration

        this.addToScope(paramNode.name, paramNode.id)

        return paramNode
      }),
    )

    if (node.expression) {
      functionNode.body.push({
        type: "return",
        id: this.getNewId(),
        arg: this.transformExpression(node.body as Expression),
      })
    } else {
      if (node.body.type !== "BlockStatement") {
        throw new Error("Arrow function with expression false should have a block statement body")
      }

      for (const statement of node.body!.body) {
        functionNode.body.push(this.transformStatement(statement))
      }
    }

    this.popScope()

    return functionNode
  }

  transformIfStatement(node: IfStatement): IfStatementNode {
    const ifStatement: IfStatementNode = {
      type: "if",
      id: this.getNewId(),
      test: this.transformExpression(node.test),
      then: [],
    }

    if (node.consequent.type === "ExpressionStatement") {
      ifStatement.then.push(this.transformExpressionStatement(node.consequent))
    } else if (node.consequent.type === "BlockStatement") {
      ifStatement.then.push(...this.transformStatementList(node.consequent.body))
    } else {
      throw new Error(`Unknown if consequent type: ${node.consequent.type}`)
    }

    // terminate else or chain else-if's

    if (node.alternate) {
      if (node.alternate.type === "ExpressionStatement") {
        ifStatement.else = [this.transformExpressionStatement(node.alternate)]
      } else if (node.alternate.type === "BlockStatement") {
        ifStatement.else = this.transformStatementList(node.alternate.body)
      } else if (node.alternate.type === "IfStatement") {
        ifStatement.elseIf = []
        let current: Statement = node.alternate

        while (current.type === "IfStatement") {
          const elseIf: ElseIfNode = {
            type: "else if",
            id: this.getNewId(),
            test: this.transformExpression(current.test),
            then: [],
          }

          if (current.consequent.type === "ExpressionStatement") {
            elseIf.then.push(this.transformExpressionStatement(current.consequent))
          } else if (current.consequent.type === "BlockStatement") {
            elseIf.then.push(...this.transformStatementList(current.consequent.body))
          } else {
            throw new Error(`Unknown if consequent type: ${current.consequent.type}`)
          }

          ifStatement.elseIf.push(elseIf)

          if (!current.alternate) {
            break
          }

          current = current.alternate
        }

        if (current.type === "ExpressionStatement") {
          ifStatement.else = [this.transformExpressionStatement(current)]
        } else if (current.type === "BlockStatement") {
          ifStatement.else = this.transformStatementList(current.body)
        }
      } else {
        throw new Error(`Unknown if alternate type: ${node.alternate.type}`)
      }
    }

    return ifStatement
  }
}

export function collapseWhitespace(str: string) {
  return str.replace(/\s+/g, " ")
}

function replaceIdentifierInASTExpression(ast: any, oldName: string, newName: string) {
  acornWalkFull(ast, (node: any) => {
    if (node.type === "Identifier" && node.name === oldName) {
      node.name = newName
    }
  })
}
